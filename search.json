[{"path":"/CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant, version 1.0.0, available https://contributor-covenant.org/version/1/0/0/","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Heather Turner. Author, maintainer. Ioannis Kosmidis. Author. David Firth. Author. Jacob van Etten. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Turner, H.L., van Etten, J., Firth, D. Kosmidis, . (2020). Modelling Rankings R: PlackettLuce Package. Computational Statistics, 35, 1027-1057. URL https://doi.org/10.1007/s00180-020-00959-3.","code":"@Article{,   title = {Modelling Rankings in {R}: The {PlackettLuce} Package},   author = {Heather L. Turner and Jacob {van Etten} and David Firth and Ioannis Kosmidis},   journal = {Computational Statistics},   year = {2020},   volume = {35},   pages = {1027--1057},   url = {https://doi.org/10.1007/s00180-020-00959-3},   doi = {10.1007/s00180-020-00959-3}, }"},{"path":"/index.html","id":"plackettluce","dir":"","previous_headings":"","what":"Plackett-Luce Models for Rankings","title":"Plackett-Luce Models for Rankings","text":"Package website: https://hturner.github.io/PlackettLuce/.","code":""},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Plackett-Luce Models for Rankings","text":"PlackettLuce package implements generalization model jointly attributed Plackett (1975) Luce (1959) modelling rankings data. Examples rankings data might finishing order competitors race, preference consumers set competing products. output model estimated worth item appears rankings. parameters generally presented log scale inference. implementation Plackett-Luce model PlackettLuce: Accommodates ties (order) rankings, e.g. bananas ≻ {apples, oranges} ≻ pears. Accommodates sub-rankings, e.g. pears ≻ apples, full set items {apples, bananas, oranges, pears}. Handles disconnected weakly connected networks implied rankings, e.g. one item always loses figure . achieved adding pseudo-rankings hypothetical ghost item.  addition package provides methods Obtaining quasi-standard errors, don’t depend constraints applied worth parameters identifiability. Fitting Plackett-Luce trees, .e. tree partitions rankings covariate values, consumer attributes racing conditions, identifying subgroups different sets worth parameters items.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Plackett-Luce Models for Rankings","text":"package may installed CRAN via development version can installed via","code":"install.packages(\"PlackettLuce\") # install.packages(\"devtools\") devtools::install_github(\"hturner/PlackettLuce\")"},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Plackett-Luce Models for Rankings","text":"Netflix Prize competition devised Netflix improve accuracy recommendation system. facilitate released ratings movies users system transformed preference data available PrefLib, (Bennett Lanning 2007). data set comprises rankings set 3 4 movies selected random. consider rankings just one set movies illustrate functionality PlackettLuce. data can read using read.soc function PlackettLuce row corresponds unique ordering four movies data set. number Netflix users assigned ordering given first column, followed four movies preference order. example, 68 users ranked movie 2 first, followed movie 1, movie 4 finally movie 3. PlackettLuce, model-fitting function PlackettLuce requires data provided form rankings rather orderings, .e.  rankings expressed giving rank item, rather ordering items. can create \"rankings\" object set orderings follows Note read.soc saved names movies \"items\" attribute netflix, used label items. Subsetting rankings object R .rankings = FALSE, returns underlying matrix rankings corresponding subset. example, first ranking second movie (Beverly Hills Cop) ranked number 1, followed first movie (Mean Girls) rank 2, followed fourth movie (Mission: Impossible II) finally third movie (Mummy Returns), giving ordering original data. Various methods provided \"rankings\" objects, particular subset rankings without .rankings = FALSE, result \"rankings\" object corresponding print method used: rankings can now passed PlackettLuce fit Plackett-Luce model. counts ranking provided downloaded data used weights fitting model. Calling coef log = FALSE gives worth parameters, constrained sum one. parameters represent probability movie ranked first. inference parameters converted log scale, default setting first parameter zero standard errors estimable: way, Mean Girls treated reference movie, positive parameter Beverly Hills Cop shows popular among users, negative parameters two movies show less popular. Comparisons different pairs movies can made visually plotting log-worth parameters comparison intervals based quasi standard errors.  intervals overlap significant difference. can see Beverly Hills Cop significantly popular three movies, Mean Girls significant popular Mummy Returns Mission: Impossible II, significant difference users’ preference last two movies.","code":"library(PlackettLuce) preflib <- \"https://www.preflib.org/static/data/ED/\" netflix <- read.soc(file.path(preflib, \"netflix/ED-00004-00000138.soc\")) head(netflix, 2) ##   Freq Rank 1 Rank 2 Rank 3 Rank 4 ## 1   68      2      1      4      3 ## 2   53      1      2      4      3 R <- as.rankings(netflix[,-1], input = \"orderings\",                  items = attr(netflix, \"items\")) R[1:3, as.rankings = FALSE] ##   Mean Girls Beverly Hills Cop The Mummy Returns Mission: Impossible II ## 1          2                 1                 4                      3 ## 2          1                 2                 4                      3 ## 3          2                 1                 3                      4 R[1:3] ##                                          1  ## \"Beverly Hills Cop > Mean Girls > Mis ...\"  ##                                          2  ## \"Mean Girls > Beverly Hills Cop > Mis ...\"  ##                                          3  ## \"Beverly Hills Cop > Mean Girls > The ...\" print(R[1:3], width = 60) ##                                                              1  ## \"Beverly Hills Cop > Mean Girls > Mission: Impossible II  ...\"  ##                                                              2  ## \"Mean Girls > Beverly Hills Cop > Mission: Impossible II  ...\"  ##                                                              3  ## \"Beverly Hills Cop > Mean Girls > The Mummy Returns > Mis ...\" mod <- PlackettLuce(R, weights = netflix$Freq) coef(mod, log = FALSE) ##             Mean Girls      Beverly Hills Cop      The Mummy Returns  ##              0.2306285              0.4510655              0.1684719  ## Mission: Impossible II  ##              0.1498342 summary(mod) ## Call: PlackettLuce(rankings = R, weights = netflix$Freq) ##  ## Coefficients: ##                        Estimate Std. Error z value Pr(>|z|)     ## Mean Girls              0.00000         NA      NA       NA     ## Beverly Hills Cop       0.67080    0.07472   8.978  < 2e-16 *** ## The Mummy Returns      -0.31404    0.07593  -4.136 3.53e-05 *** ## Mission: Impossible II -0.43128    0.07489  -5.759 8.47e-09 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual deviance:  3493.5 on 3525 degrees of freedom ## AIC:  3499.5  ## Number of iterations: 7 qv <- qvcalc(mod) plot(qv, ylab = \"Worth (log)\", main = NULL)"},{"path":"/index.html","id":"going-further","dir":"","previous_headings":"","what":"Going Further","title":"Plackett-Luce Models for Rankings","text":"core functionality PlackettLuce illustrated package vignette, along details model used package comparison packages. vignette can found package website within R package installed, e.g. via","code":"vignette(\"Overview\", package = \"PlackettLuce\")"},{"path":"/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Plackett-Luce Models for Rankings","text":"Please note project released Contributor Code Conduct. participating project agree abide terms.","code":""},{"path":[]},{"path":"/reference/PlackettLuce-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated functions in package PlackettLuce — PlackettLuce-deprecated","title":"Deprecated functions in package PlackettLuce — PlackettLuce-deprecated","text":"functions listed deprecated defunct near future. possible, alternative functions similar functionality also mentioned.","code":""},{"path":"/reference/PlackettLuce-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated functions in package PlackettLuce — PlackettLuce-deprecated","text":"","code":"grouped_rankings(rankings, index, ...)"},{"path":"/reference/PlackettLuce-deprecated.html","id":"grouped-rankings","dir":"Reference","previous_headings":"","what":"grouped_rankings","title":"Deprecated functions in package PlackettLuce — PlackettLuce-deprecated","text":"grouped_rankings() replaced group().","code":""},{"path":"/reference/PlackettLuce-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Plackett-Luce Models for Rankings — PlackettLuce-package","title":"Plackett-Luce Models for Rankings — PlackettLuce-package","text":"Plackett-Luce provides functions prepare rankings data order fit Plackett-Luce model Plackett-Luce trees. implementation can handle ties, sub-rankings rankings imply disconnected weakly connected preference networks. Methods provided summary inference.","code":""},{"path":"/reference/PlackettLuce-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plackett-Luce Models for Rankings — PlackettLuce-package","text":"main function package model-fitting function PlackettLuce help file function provides details Plackett-Luce model, extended accommodate ties. Rankings data must passed PlackettLuce specific form, see rankings details. functions handling rankings include choices express rankings choices alternatives; adjacency create adjacency matrix wins losses implied rankings connectivity check connectivity underlying preference network. Several methods available inspect fitted Plackett-Luce models, help files available less common methods arguments may specified: coef, deviance, fitted, itempar, logLik, print, qvcalc, summary, vcov. PlackettLuce also provides function pltree fit Plackett-Luce tree .e. tree partitions rankings covariate values, identifying subgroups different sets worth parameters items. case group must used prepare data. Several data sets provided package: beans, nascar, pudding. help files give illustration preparing rankings data modelling. read.soc function enables example data sets \"Strict Orders - Complete List\" format (.e. complete rankings ties) downloaded PrefLib. full explanation methods illustrations using package data sets given vignette, vignette(\"Overview\", package = \"PlackettLuce\").","code":""},{"path":"/reference/PlackettLuce.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Plackett-Luce Model — PlackettLuce","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"Fit Plackett-Luce model set rankings. rankings may partial (ranking completely ranks subset items) include ties arbitrary order.","code":""},{"path":"/reference/PlackettLuce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"","code":"PlackettLuce(   rankings,   npseudo = 0.5,   normal = NULL,   gamma = NULL,   adherence = NULL,   weights = freq(rankings),   na.action = getOption(\"na.action\"),   start = NULL,   method = c(\"iterative scaling\", \"BFGS\", \"L-BFGS\"),   epsilon = 1e-07,   steffensen = 0.1,   maxit = c(500, 10),   trace = FALSE,   verbose = TRUE,   ... )"},{"path":"/reference/PlackettLuce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"rankings \"rankings\" object, object can coerced .rankings.  \"aggregated_rankings\" object can used specify rankings weights simultaneously. \"grouped_rankings\" object used estimating adherence rankers multiple rankings per ranker. npseudo using pseudodata: number wins losses add object hypothetical reference object. normal optional list elements named mu Sigma specifying mean covariance matrix multivariate normal prior log worths. gamma optional list elements named shape rate specifying parameters gamma prior adherence parameters ranker (use grouped_rankings group multiple rankings ranker). short-cut TRUE may used specify Gamma(10, 10) prior. NULL (FALSE), adherence fixed adherence rankers. adherence optional vector adherence values ranker. missing, adherence fixed 1 rankers. gamma NULL, specifies starting values adherence. weights optional vector weights ranking. na.action function handle missing rankings, see na.omit(). start starting values worth parameters tie parameters raw scale (worth parameters need scaled sum 1). normal specified, exp(normal$mu) used starting values worth parameters. Coefficients previous fit can passed result call  coef.PlackettLuce, coefficients element \"PlackettLuce\" object. method method used fitting: \"iterative scaling\" (iterative scaling sequentially update parameter values), \"BFGS\" (BFGS optimisation algorithm optim interface), \"L-BFGS\" (limited-memory BFGS optimisation algorithm implemented lbfgs package). Iterative scaling used default, unless prior specified normal gamma, case default \"BFGS\". epsilon maximum absolute difference observed expected sufficient statistics ability parameters convergence. steffensen threshold defined epsilon apply Steffensen acceleration iterative scaling updates. maxit vector specifying maximum number iterations. gamma NULL, first element used specifies maximum number iterations algorithm specified method. gamma NULL, second element may supplied specify maximum number iterations alternating algorithm, adherence parameters updated alternately parameters. default use 10 outer iterations. trace logical, TRUE show trace iterations. verbose logical, TRUE show messages validity checks rankings. ... additional arguments passed optim lbfgs. particular convergence tolerance may adjusted using e.g. control = list(reltol = 1e-10).","code":""},{"path":"/reference/PlackettLuce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"object class \"PlackettLuce\", list containing following elements: call matched call. coefficients model coefficients. loglik maximized log-likelihood. null.loglik maximized log-likelihood null model (alternatives including ties equal probability). df.residual residual degrees freedom. df.null residual degrees freedom null model. rank rank model. logposterior prior specified, maximised log posterior. gamma gamma prior specified, list parameters. normal normal prior specified, list parameters. iter number iterations run. rankings rankings passed rankings, converted \"rankings\" object necessary. weights weights applied ranking fitting. adherence fixed estimated adherence per ranker. ranker ranker index mapping rankings rankers (\"index\" attribute rankings specified \"grouped_rankings\" object.) ties observed tie orders corresponding estimated tie parameters. conv convergence code: 0 successful convergence; 1 reached maxit (outer) iterations without convergence; 2 Steffensen acceleration cause log-likelihood increase; negative number L-BFGS algorithm failed reason.","code":""},{"path":"/reference/PlackettLuce.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"maximum tie order increases, number possible choices rank increases rapidly, particularly total number items high. means model slower fit higher \\(D\\). addition, due current implementation vcov() method, computation standard errors (summary()) can take almost long model fit may even become infeasible due memory limits. rule thumb, > 10 items > 1000 rankings, recommend PlackettLuce() ties order 4. higher order ties, rank-ordered logit model, see ROlogit::rologit() generalized Mallows Model BayesMallows::compute_mallows() may suitable, model tied events explicitly.","code":""},{"path":"/reference/PlackettLuce.html","id":"model-definition","dir":"Reference","previous_headings":"","what":"Model definition","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"single ranking given $$R = \\{C_1, C_2, \\ldots, C_J\\}$$ items set \\(C_1\\) ranked higher (better ) items \\(C_2\\), . multiple objects set \\(C_j\\) items tied ranking. set items \\(S\\), let $$f(S) = \\delta_{|S|}       \\left(\\prod_{\\S} \\alpha_i \\right)^\\frac{1}{|S|}$$ \\(|S|\\) cardinality (size) set, \\(\\delta_n\\) parameter related prevalence ties order \\(n\\) (\\(\\delta_1 \\equiv 1\\)), \\(\\alpha_i\\) parameter representing worth item \\(\\). extension Plackett-Luce model allowing ties order \\(D\\), probability ranking \\(R\\) given $$\\prod_{j = 1}^J \\frac{f(C_j)}{       \\sum_{k = 1}^{\\min(D_j, D)} \\sum_{S \\{A_j \\choose k}} f(S)}$$ \\(D_j\\) cardinality \\(A_j\\), set alternatives \\(C_j\\) chosen, \\(A_j \\choose k\\) possible choices \\(k\\) items \\(A_j\\). value \\(D\\) can set maximum number tied items observed data, \\(\\delta_n = 0\\) \\(n > D\\). worth parameters constrained sum one, represent probability corresponding item comes first ranking items, given first place tied. 2-way tie prevalence parameter \\(\\delta_2\\) related probability two items equal worth tie first place, given first place 3-way higher tie. Specifically, probability \\(\\delta_2/(2 + \\delta_2)\\). 3-way higher tie-prevalence parameters similarly interpretable, terms tie probabilities among equal-worth items. intermediate tie orders observed (e.g. ties order 2 order 4 observed, ties order 3), maximum likelihood estimate corresponding tie prevalence parameters zero, parameters excluded model.","code":""},{"path":"/reference/PlackettLuce.html","id":"pseudo-rankings","dir":"Reference","previous_headings":"","what":"Pseudo-rankings","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"order maximum likelihood estimate object's worth defined, network rankings must strongly connected. means every possible partition objects two nonempty subsets, object second set ranked higher object first set least . network rankings strongly connected pseudo-rankings may used connect network. approach posits hypothetical object log-worth 0 adds npseudo wins npseudo losses set rankings. parameter npseudo prior strength.  npseudo = 0 MLE posterior mode.  npseudo approaches infinity log-worth estimates shrink towards 0. default, npseudo = 0.5, sufficient connect network weak shrinkage effect. Even networks already connected, adding pseudo-rankings typically reduces bias variance estimators worth parameters.","code":""},{"path":"/reference/PlackettLuce.html","id":"incorporating-prior-information-on-log-worths","dir":"Reference","previous_headings":"","what":"Incorporating prior information on log-worths","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"Prior information can incorporated using normal specify multivariate normal prior log-worths. log-worths estimated maximum posteriori (MAP) estimation. Model summaries (deviance, AIC, standard errors) based log-likelihood evaluated MAP estimates, resulting finite sample bias disappear number rankings increases. Inference based model summaries valid long prior considered fixed tuned part model. Incorporating prior alternative method penalization, therefore npseudo set zero prior specified.","code":""},{"path":"/reference/PlackettLuce.html","id":"incorporating-ranker-adherence-parameters","dir":"Reference","previous_headings":"","what":"Incorporating ranker adherence parameters","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"rankings come different rankers, model can extended allow varying reliability rankers, proposed Raman Joachims (2014). particular, replacing \\(f(S)\\) $$h(S) = \\delta_{|S|}       \\left(\\prod_{\\S} \\alpha_i \\right)^\\frac{\\eta_g}{|S|}$$ \\(\\eta_g > 0\\) adherence parameter ranker \\(g\\). standard model, rankers assumed equal reliability, \\(\\eta_g = 1\\) rankers. Higher \\(\\eta_g = 1\\) increases distance item worths, giving greater weight' ranker's choice. Conversely, lower \\(\\eta_g = 1\\) shrinks item worths towards equality ranker's choice less relevant. adherence parameters estimable maximum likelihood, since given item worths maximum likelihood estimate adherence infinity rankers give rankings consistent items ordered worth zero rankers. Therefore essential include prior adherence parameters estimated rather fixed. Setting gamma = TRUE specifies default \\(\\Gamma(10,10)\\) prior, mean 1 probability 0.99 adherence 0.37 2. Alternative parameters can specified list elements shape rate. Setting scale rate common value \\(\\theta\\) specifies mean 1; \\(\\theta \\ge\\) 2 give low prior probability near-zero adherence; \\(\\theta\\) increases density becomes concentrated (symmetrical) 1. Since number adherence parameters typically large assumed worth tie parameters primary interest, adherence parameters included model summaries, included returned object.","code":""},{"path":"/reference/PlackettLuce.html","id":"controlling-the-fit","dir":"Reference","previous_headings":"","what":"Controlling the fit","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"models without priors, using nspseudo = 0 use standard maximum likelihood, network connected (throw error otherwise). fitting algorithm set method argument. default method \"iterative scaling\" slow reliable approach. addition, control accuracy final fit, since convergence determined direct comparison observed expected values sufficient statistics worth parameters, rather tolerance change log-likelihood. \"iterative scaling\" algorithm slow first order method (use derivatives likelihood). set starting values 'close enough' final solution, algorithm can accelerated using Steffensen's method. PlackettLuce attempts apply Steffensen's acceleration differences observed expected values sufficient statistics less steffensen. ad-hoc rule defining 'close enough' cases acceleration may produce negative worth parameters decrease log-likelihood. PlackettLuce apply update makes improvement. \"BFGS\" \"L-BFGS\" algorithms second order methods, therefore can quicker default method. Control parameters can passed optim lbfgs. models priors, iterative scaling method used, BFGS used default.","code":""},{"path":"/reference/PlackettLuce.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"Raman, K. Joachims, T. (2014)  Methods Ordinal Peer Grading. arXiv:1404.3656.","code":""},{"path":[]},{"path":"/reference/PlackettLuce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Plackett-Luce Model — PlackettLuce","text":"","code":"# Six partial rankings of four objects, 1 is top rank, e.g # first ranking: item 1, item 2 # second ranking: item 2, item 3, item 4, item 1 # third ranking: items 2, 3, 4 tie for first place, item 1 second R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\")  # create rankings object R <- as.rankings(R)  # Standard maximum likelihood estimates mod_mle <- PlackettLuce(R, npseudo = 0) coef(mod_mle) #>      apple     banana     orange       pear       tie2       tie3  #>  0.0000000  0.2942875 -0.7335113 -0.1190960 -1.8619467 -0.7369735   # Fit with default settings mod <- PlackettLuce(R) # log-worths are shrunk towards zero coef(mod) #>       apple      banana      orange        pear        tie2        tie3  #>  0.00000000  0.25287379 -0.61350684 -0.08688475 -2.15068111 -0.79245358   # independent N(0, 9) priors on log-worths, as in Raman and Joachims prior <- list(mu = rep(0, ncol(R)),               Sigma = diag(rep(9, ncol(R)))) mod_normal <- PlackettLuce(rankings = R, normal = prior) # slightly weaker shrinkage effect vs pseudo-rankings, # with less effect on tie parameters (but note small number of rankings here) coef(mod_normal) #>      apple     banana     orange       pear       tie2       tie3  #>  0.0000000  0.2753696 -0.6772960 -0.1030173 -1.8679502 -0.7453151   # estimate adherence assuming every ranking is from a separate ranker mod_separate <- PlackettLuce(rankings = R, normal = prior, gamma = TRUE) coef(mod_separate) #>      apple     banana     orange       pear       tie2       tie3  #>  0.0000000  0.2310944 -0.8436801 -0.1654011 -1.8637839 -0.7405627  # gives more weight to rankers 4 & 6 which rank apple first, # so worth of apple increased relative to banana mod_separate$adherence #> [1] 0.8889778 0.8732159 0.8876840 0.9431440 0.8818594 0.9506536  # estimate adherence based on grouped rankings #  - assume two rankings from each ranker G <- group(R, rep(1:3, each = 2)) mod_grouped <- PlackettLuce(rankings = G, normal = prior, gamma = TRUE) coef(mod_grouped) #>      apple     banana     orange       pear       tie2       tie3  #>  0.0000000  0.2855958 -0.7611189 -0.1201862 -1.8678374 -0.7453447  # first ranker is least consistent so down-weighted mod_grouped$adherence #> [1] 0.8834957 0.9137346 0.9144347"},{"path":"/reference/adjacency.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Adjacency Matrix for a set of Rankings — adjacency","title":"Create an Adjacency Matrix for a set of Rankings — adjacency","text":"Convert set rankings adjacency matrix summarising wins losses pairs items.","code":""},{"path":"/reference/adjacency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Adjacency Matrix for a set of Rankings — adjacency","text":"","code":"adjacency(object, weights = NULL, ...)"},{"path":"/reference/adjacency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Adjacency Matrix for a set of Rankings — adjacency","text":"object rankings object, object can coerced .rankings. weights optional vector weights rankings. ... arguments passed /methods.","code":""},{"path":"/reference/adjacency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Adjacency Matrix for a set of Rankings — adjacency","text":"N N matrix, N number items can ranked.","code":""},{"path":"/reference/adjacency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an Adjacency Matrix for a set of Rankings — adjacency","text":"\"rankings\" object based N items, adjacency matrix N N matrix, element (, j) number times item wins item j. example, ranking \\1\\ > \\3, 4\\ > \\2\\, item 1 wins items 2, 3, 4, items 3 4 win item 2. weights specified, values adjacency matrix weighted counts.","code":""},{"path":"/reference/adjacency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Adjacency Matrix for a set of Rankings — adjacency","text":"","code":"X <- matrix(c(2, 1, 2, 1, 2,               3, 2, 0, 0, 1,               1, 0, 2, 2, 3), nrow = 3, byrow = TRUE) X <- as.rankings(X) adjacency(X) #>   1 2 3 4 5 #> 1 0 0 1 1 1 #> 2 2 0 1 0 1 #> 3 0 0 0 0 1 #> 4 1 0 1 0 2 #> 5 1 1 0 0 0 #> attr(,\"class\") #> [1] \"adjacency\" \"matrix\"     adjacency(X, weights = c(1, 1, 2)) #>   1 2 3 4 5 #> 1 0 0 2 2 2 #> 2 2 0 1 0 1 #> 3 0 0 0 0 2 #> 4 1 0 1 0 3 #> 5 1 1 0 0 0 #> attr(,\"class\") #> [1] \"adjacency\" \"matrix\""},{"path":"/reference/aggregate.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate Rankings — aggregate","title":"Aggregate Rankings — aggregate","text":"Aggregate rankings, returning \"aggregated_rankings\" object unique rankings frequencies. frequencies can extracted via function freq().","code":""},{"path":"/reference/aggregate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate Rankings — aggregate","text":"","code":"# S3 method for rankings aggregate(x, freq = NULL, ...)  as.aggregated_rankings(x, ...)  # S3 method for aggregated_rankings [(x, i, j, ..., drop = FALSE, as.aggregated_rankings = TRUE)  freq(x)"},{"path":"/reference/aggregate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate Rankings — aggregate","text":"x \"rankings\" object aggregate(); object can coerced \"aggregated_rankings\" object .aggregated_rankings(), otherwise \"aggregated_rankings\" object. freq vector frequencies rankings previously aggregated. ... Additional arguments, currently unused. indices specifying rankings extract, [. j indices specifying items extract, [. drop TRUE return single row/column matrices vector. .aggregated_rankings TRUE create \"aggregated_rankings\" object indexed rankings. Otherwise index underlying matrix ranks return data frame corresponding frequencies.","code":""},{"path":"/reference/aggregate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate Rankings — aggregate","text":"data frame class \"aggregated_rankings\", columns ranking \"rankings\" object unique rankings. freq corresponding frequencies. Methods available rbind() .matrix().","code":""},{"path":[]},{"path":"/reference/aggregate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate Rankings — aggregate","text":"","code":"# create a rankings object with duplicated rankings R <- matrix(c(1, 2, 0, 0,               0, 1, 2, 3,               2, 1, 1, 0,               1, 2, 0, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\") R <- as.rankings(R)  # aggregate the rankings A <- aggregate(R)  # subsetting applies to the rankings, e.g. first two unique rankings A[1:2] #>                  ranking freq #> 1         apple > banana    2 #> 2 banana > orange > pear    1  # (partial) rankings of items 2 to 4 only A[, 2:4] #> Recoded rankings that are not in dense form #> Rankings with only 1 item set to `NA` #>                  ranking freq #> 1                   <NA>    2 #> 2 banana > orange > pear    1 #> 3        banana = orange    2 #> 4          pear > orange    1  # convert to a matrix as.matrix(A) #>      apple banana orange pear freq #> [1,]     1      2      0    0    2 #> [2,]     0      1      2    3    1 #> [3,]     2      1      1    0    2 #> [4,]     1      0      3    2    1  # frequencies are automatically used as weights by PlackettLuce() mod <- PlackettLuce(A) mod$weights #> [1] 2 1 2 1"},{"path":"/reference/beans.html","id":null,"dir":"Reference","previous_headings":"","what":"Preferred Bean Varieties in Nicaragua — beans","title":"Preferred Bean Varieties in Nicaragua — beans","text":"subset data trials bean varieties (Phaseolus vulgaris L.) Nicaragua five growing seasons. Farmers asked try three varieties bean total ten varieties rank order preference. addition, variety farmers asked compare trial variety local variety state whether considered better worse.","code":""},{"path":"/reference/beans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Preferred Bean Varieties in Nicaragua — beans","text":"","code":"beans"},{"path":"/reference/beans.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Preferred Bean Varieties in Nicaragua — beans","text":"data frame 842 records 14 variables: variety_a name variety comparison. variety_b name variety B comparison. variety_c name variety C comparison. best variety farmer ranked first place (\"\", \"B\" \"C\"). worst variety farmer ranked last place (\"\", \"B\" \"C\"). var_a farmer ranked variety compared local variety (\"Worse\" \"Better\"). var_b farmer ranked variety B compared local variety (\"Worse\" \"Better\"). var_c farmer ranked variety C compared local variety (\"Worse\" \"Better\"). season factor specifying growing season (\"Po - 15\", \"Ap - 15\", \"Pr - 16\", \"Po - 16\", \"Ap - 16\". year year planting. maxTN maximum temperature night vegetative cycle (degrees Celsius). lon geographic coordinate longitude (X axis) plot established. lat geographic coordinate latitude (Y axis) plot established. planting_date Date, specifying start date planting trial.","code":""},{"path":"/reference/beans.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Preferred Bean Varieties in Nicaragua — beans","text":"van Etten, J. et al. (2019) PNAS, 116 (10), 4194--4199, doi:10.1073/pnas.1813720116 .","code":""},{"path":"/reference/beans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Preferred Bean Varieties in Nicaragua — beans","text":"three crop seasons Central America: Primera May - August. Postrera September - October. Apante November - January. Beans can planted near beginning season, though commonly planted Postrera Apante seasons.","code":""},{"path":"/reference/beans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Preferred Bean Varieties in Nicaragua — beans","text":"","code":"# Consider the best and worst rankings. These give the variety the # farmer thought was best or worst, coded as A, B or C for the # first, second or third variety assigned to the farmer # respectively. data(beans) head(beans[c(\"best\", \"worst\")], 2) #>   best worst #> 1    C     A #> 2    B     A  # Fill in the missing item beans$middle <- complete(beans[c(\"best\", \"worst\")],                          items = c(\"A\", \"B\", \"C\")) head(beans[c(\"best\", \"middle\", \"worst\")], 2) #>   best middle worst #> 1    C      B     A #> 2    B      C     A  # This gives an ordering of the three varieties the farmer was # given. The names of these varieties are stored in separate # columns varieties <- beans[c(\"variety_a\", \"variety_b\", \"variety_c\")] head(varieties, 2) #>     variety_a       variety_b   variety_c #> 1 BRT 103-182      SJC 730-79 PM2 Don Rey #> 2   INTA Rojo INTA Centro Sur INTA Sequia  # Use these names to decode the orderings of order 3 order3 <- decode(beans[c(\"best\", \"middle\", \"worst\")],                  items = beans[c(\"variety_a\", \"variety_b\", \"variety_c\")],                  code = c(\"A\", \"B\", \"C\"))  # Now consider the paired comparisons agains the local variety head(beans[c(\"var_a\", \"var_b\", \"var_c\")], 2) #>   var_a  var_b  var_c #> 1 Worse  Worse Better #> 2 Worse Better Better  # Convert these results to a vector and get the corresponding trial variety outcome <- unlist(beans[c(\"var_a\", \"var_b\", \"var_c\")]) trial_variety <- unlist(beans[c(\"variety_a\", \"variety_b\", \"variety_c\")])  # Create a data frame of the implied orderings of order 2 order2 <- data.frame(Winner = ifelse(outcome == \"Worse\",                                      \"Local\", trial_variety),                      Loser = ifelse(outcome == \"Worse\",                                     trial_variety, \"Local\"),                      stringsAsFactors = FALSE, row.names = NULL) head(order2, 2) #>   Winner       Loser #> 1  Local BRT 103-182 #> 2  Local   INTA Rojo  # Finally combine the rankings of order 2 and order 3 R <- rbind(as.rankings(order3, input = \"orderings\"),            as.rankings(order2, input = \"orderings\")) head(R) #> [1] \"PM2 Don Rey > SJC 730-79 > BRT 103-182\"   #> [2] \"INTA Centro Sur > INTA Sequia > INTA ...\" #> [3] \"INTA Ferroso > INTA Matagalpa > BRT  ...\" #> [4] \"INTA Rojo > INTA Centro Sur > ALS 0532-6\" #> [5] \"PM2 Don Rey > INTA Sequia > SJC 730-79\"   #> [6] \"ALS 0532-6 > INTA Matagalpa > INTA Rojo\"  tail(R) #> [1] \"INTA Sequia > Local\"    \"INTA Sequia > Local\"    \"BRT 103-182 > Local\"    #> [4] \"Local > INTA Matagalpa\" \"Local > INTA Rojo\"      \"Local > SJC 730-79\""},{"path":"/reference/choices.html","id":null,"dir":"Reference","previous_headings":"","what":"Choices Object — choices","title":"Choices Object — choices","text":"Convert set rankings list choices, alternatives, rankings. choices corresponding alternatives make exchangeable part Plackett-Luce ties.","code":""},{"path":"/reference/choices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Choices Object — choices","text":"","code":"choices(rankings, names = FALSE)"},{"path":"/reference/choices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Choices Object — choices","text":"rankings \"rankings\" object, object can coerced .rankings. names logical: TRUE use object names returned \"choices\" object, else use object indices.","code":""},{"path":"/reference/choices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Choices Object — choices","text":"data frame class \"choices\" elements: choices list element represents set items chosen single rank ranking. alternatives list element represents set items choose single rank ranking. ranking list element represents ranking choice belongs . list stores number choices names objects attributes \"nchoices\" \"objects\" respectively.","code":""},{"path":"/reference/choices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Choices Object — choices","text":"","code":"R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\")  actual_choices <- choices(R, names = TRUE) actual_choices[1:6,] #> Ranking: 1  #> --------------  #> {apple} from {apple, banana}  #> {banana} from {banana}  #> ==============  #> Ranking: 2  #> --------------  #> {banana} from {apple, banana, orange, pear}  #> {orange} from {apple, orange, pear}  #> {pear} from {apple, pear}  #> {apple} from {apple}  #> ==============   coded_choices <- choices(R, names = FALSE) coded_choices[1:2,] #> Ranking: 1  #> --------------  #> {1} from {1, 2}  #> {2} from {2}  #> ==============  as.data.frame(coded_choices)[1:2,] #>   choices alternatives ranking #> 1       1         1, 2       1 #> 2       2            2       1 attr(coded_choices, \"objects\") #> [1] \"apple\"  \"banana\" \"orange\" \"pear\""},{"path":"/reference/complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete Orderings with the Missing Redundant Rank — complete","title":"Complete Orderings with the Missing Redundant Rank — complete","text":"Given orderings one rank missing, complete ordering assigning remaining item(s) final rank.","code":""},{"path":"/reference/complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete Orderings with the Missing Redundant Rank — complete","text":"","code":"complete(orderings, items)"},{"path":"/reference/complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete Orderings with the Missing Redundant Rank — complete","text":"orderings data frame orderings one rank missing. items vector item names.","code":""},{"path":"/reference/complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete Orderings with the Missing Redundant Rank — complete","text":"vector missing items, list ties.","code":""},{"path":"/reference/complete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complete Orderings with the Missing Redundant Rank — complete","text":"","code":"# Orderings of 3 items, when only the best and worst are recorded orderings <- data.frame(best = c(\"A\", \"B\", \"A\"),                         worst = c(\"C\", \"C\", NA)) orderings$middle <- complete(orderings, items = c(\"A\", \"B\", \"C\"))"},{"path":"/reference/connectivity.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Connectivity of Rankings — connectivity","title":"Check Connectivity of Rankings — connectivity","text":"Check connectivity network underlying set rankings.","code":""},{"path":"/reference/connectivity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Connectivity of Rankings — connectivity","text":"","code":"connectivity(x, verbose = TRUE)"},{"path":"/reference/connectivity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Connectivity of Rankings — connectivity","text":"x adjacency matrix returned adjacency, \"rankings\" object, object can coerced .rankings. verbose logical, TRUE, message given network strongly connected.","code":""},{"path":"/reference/connectivity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Connectivity of Rankings — connectivity","text":"list elements membership labelled vector indices specifying membership clusters network items csize sizes clusters network items number clusters network items","code":""},{"path":"/reference/connectivity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check Connectivity of Rankings — connectivity","text":"Ranked items connected directed graph according implied wins loses pairs items. wins losses can summarised adjacency matrix using adjacency. adjacency matrix, graph inferred checked connectivity. message given network strongly connected, .e. least one win one loss partitions network two groups. Features clusters network returned - network strongly connected, items belong cluster.","code":""},{"path":"/reference/connectivity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Connectivity of Rankings — connectivity","text":"","code":"## weakly connected network: ## one win between two clusters X <- matrix(c(1, 2, 0, 0,               2, 1, 3, 0,               0, 0, 1, 2,               0, 0, 2, 1), ncol = 4, byrow = TRUE) X <- as.rankings(X) res <- connectivity(X) #> Network of items is not strongly connected res$membership #> 1 2 3 4  #> 1 1 2 2  ## keep items in cluster 1 na.omit(X[,res$membership == 1]) #> [1] \"1 > 2\" \"2 > 1\"  ## two weakly connected items: ## item 1 always loses; item 4 only wins against item 1 X <- matrix(c(4, 1, 2, 3,               0, 2, 1, 3), nr = 2, byrow = TRUE) X <- as.rankings(X) res <- connectivity(X) #> Network of items is not strongly connected res$membership #> 1 2 3 4  #> 3 1 1 2   ## item 1 always wins; item 4 always loses X <- matrix(c(1, 2, 3, 4,               1, 3, 2, 4), nr = 2, byrow = TRUE) res <- connectivity(as.rankings(X)) #> Network of items is not strongly connected res$membership #> 1 2 3 4  #> 1 2 2 3   ## all in separate clusters: always 1 > 2 > 3 > 4 ## also miscoded rankings and redundant ranking X <- matrix(c(1, 2, 3, 4,               1, 0, 2, 3,               1, 1, 2, 0,               1, 0, 3, 4,               2, 2, 0, 4,               0, 0, 3, 0,               2, 4, 0, 0), ncol = 4, byrow = TRUE) res <- connectivity(as.rankings(X)) #> Recoded rankings that are not in dense form #> Rankings with only 1 item set to `NA` #> Network of items is not strongly connected res$membership #> 1 2 3 4  #> 1 2 3 4"},{"path":"/reference/decode.html","id":null,"dir":"Reference","previous_headings":"","what":"Decode Orderings using a Key to Item Names — decode","title":"Decode Orderings using a Key to Item Names — decode","text":"Decode orderings replacing numeric character coded values item names.","code":""},{"path":"/reference/decode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decode Orderings using a Key to Item Names — decode","text":"","code":"decode(orderings, items, code = NULL)"},{"path":"/reference/decode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decode Orderings using a Key to Item Names — decode","text":"orderings data frame coded orderings. items data frame items ranking, vector common items. code (Optional) vector giving key code. missing, names(items) used character code, seq(items) used numeric code.","code":""},{"path":"/reference/decode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decode Orderings using a Key to Item Names — decode","text":"data frame coded values replaced item names.","code":""},{"path":"/reference/decode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Decode Orderings using a Key to Item Names — decode","text":"","code":"# orderings of up to 3 items coded as A, B, C orderings <- data.frame(Rank1 = c(\"A\", \"B\"),                         Rank2 = c(\"C\", \"A\"),                         Rank3 = c(\"B\", NA),                         stringsAsFactors = FALSE) items <- data.frame(A = c(\"banana\", \"apple\"),                     B = c(\"orange\", \"pear\"),                     C = c(\"apple\", NA),                     stringsAsFactors = FALSE) decode(orderings, items) #>    Rank1 Rank2  Rank3 #> 1 banana apple orange #> 2   pear apple   <NA>  # orderings with ties of up to 3 items, coded 1:3 orderings <- data.frame(Rank1 = c(1, 3),                         Rank2 = I(list(c(2, 3), 2)),                         Rank3 = c(NA, 1),                         stringsAsFactors = FALSE) items <- data.frame(A = c(\"banana\", \"apple\"),                     B = c(\"orange\", \"pear\"),                     C = c(\"apple\", \"orange\"),                     stringsAsFactors = FALSE) decode(orderings, items) #>    Rank1         Rank2 Rank3 #> 1 banana orange, apple  <NA> #> 2 orange          pear apple  # same items in each comparison items <- c(A = \"banana\", B = \"orange\", C = \"pear\") decode(orderings, items) #>    Rank1        Rank2  Rank3 #> 1 banana orange, pear   <NA> #> 2   pear       orange banana"},{"path":"/reference/fitted.PlackettLuce.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted Probabilities for PlackettLuce Objects — fitted.PlackettLuce","title":"Fitted Probabilities for PlackettLuce Objects — fitted.PlackettLuce","text":"Fitted probabilities choice/alternative combinations data.","code":""},{"path":"/reference/fitted.PlackettLuce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted Probabilities for PlackettLuce Objects — fitted.PlackettLuce","text":"","code":"# S3 method for PlackettLuce fitted(object, aggregate = TRUE, free = TRUE, ...)  # S3 method for pltree fitted(object, aggregate = TRUE, free = TRUE, ...)"},{"path":"/reference/fitted.PlackettLuce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted Probabilities for PlackettLuce Objects — fitted.PlackettLuce","text":"object object returned PlackettLuce pltree. aggregate logical; TRUE observations choice set alternatives aggregated. free logical; TRUE free choices included, .e. choices one item set one item excluded. ... arguments, currently ignored.","code":""},{"path":"/reference/fitted.PlackettLuce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted Probabilities for PlackettLuce Objects — fitted.PlackettLuce","text":"list following components choices selected item(s). alternatives set item(s) choice made . ranking ranking(s) including choice. n weighted count rankings including choice (equal ranking weight aggregate = FALSE. fitted fitted probability making choice. object \"pltree\" object, list additional element, node, specifying node ranking corresponds .","code":""},{"path":[]},{"path":"/reference/fitted.PlackettLuce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted Probabilities for PlackettLuce Objects — fitted.PlackettLuce","text":"","code":"R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\")  mod <- PlackettLuce(R) fit <- fitted(mod) fit #>    choices alternatives ranking     fitted n #> 1        1         1, 2       1 0.41325484 1 #> 2        2   1, 2, 3, 4       2 0.21428983 1 #> 3        3      1, 3, 4       2 0.17489657 1 #> 4        4         1, 4       2 0.45200924 1 #> 5  2, 3, 4   1, 2, 3, 4       3 0.06489882 1 #> 6        1      1, 2, 3       4 0.28204215 1 #> 7        2         2, 3       4 0.66847071 1 #> 8     2, 3      1, 2, 3       5 0.02741414 1 #> 9        1      1, 3, 4       6 0.32301592 1 #> 10       4         3, 4       6 0.59521895 1"},{"path":"/reference/group.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Rankings — group","title":"Group Rankings — group","text":"Create object class \"grouped_rankings\" associates group index object class \"rankings\". allows rankings linked covariates group-specific values basis model-based recursive partitioning, see pltree.","code":""},{"path":"/reference/group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Rankings — group","text":"","code":"group(x, index, ...)  as.grouped_rankings(x, ...)  # S3 method for paircomp as.grouped_rankings(x, ...)  # S3 method for grouped_rankings [(x, i, j, ..., drop = TRUE, as.grouped_rankings = TRUE)  # S3 method for grouped_rankings format(x, max = 2L, width = 20L, ...)"},{"path":"/reference/group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Rankings — group","text":"x \"rankings\" object group(); object can coerced \"grouped_rankings\" object .grouped_rankings(), otherwise \"grouped_rankings\" object. index numeric vector length equal number rankings specifying subject ranking. ... additional arguments passed .rankings grouped_rankings .grouped_rankings; unused format. indices specifying groups extract, may data type accepted [. j indices specifying items extract, [. drop TRUE return single row/column matrices vector. .grouped_rankings TRUE return grouped_rankings object, otherwise return matrix/vector. max maximum number rankings format per subject. width maximum width number characters format ranking.","code":""},{"path":"/reference/group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Rankings — group","text":"object class \"grouped_rankings\", vector group IDs following attributes: rankings \"rankings\" object. index index match ranking group ID. R matrix items ordered last first place, ranking. S rankings matrix ranks replaced size chosen set free choices zero forced choices. id list elements adjacency matrix incremented ranking.","code":""},{"path":[]},{"path":"/reference/group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group Rankings — group","text":"","code":"# ungrouped rankings (5 rankings, 4 items) R <- as.rankings(matrix(c(1, 2, 0, 0,                           0, 2, 1, 0,                           0, 0, 1, 2,                           2, 1, 0, 0,                           0, 1, 2, 3), ncol = 4, byrow = TRUE)) length(R) #> [1] 5 R #> [1] \"1 > 2\"     \"3 > 2\"     \"3 > 4\"     \"2 > 1\"     \"2 > 3 > 4\"  # group rankings (first three in group 1, next two in group 2) G <- group(R, c(1, 1, 1, 2, 2)) length(G) #> [1] 2  ## by default up to 2 rankings are shown per group, \"...\" indicates if ## there are further rankings G #>                   1                   2  #> \"1 > 2, 3 > 2, ...\"  \"2 > 1, 2 > 3 > 4\"  print(G, max = 1) #>            1            2  #> \"1 > 2, ...\" \"2 > 1, ...\"   ## select rankings from group 1 G[1,] #>                   1  #> \"1 > 2, 3 > 2, ...\"   ## exclude item 3 from ranking G[, -3] #> Recoded rankings that are not in dense form #> Rankings with only 1 item set to `NA` #>                1                2  #> \"1 > 2, NA, ...\"   \"2 > 1, 2 > 4\"   ## rankings from group 2, excluding item 3 ## - note group 2 becomes the first group G[2, -3] #> Recoded rankings that are not in dense form #>              1  #> \"2 > 1, 2 > 4\"   ## index underlying rankings without creating new grouped_rankings object G[2, -3, as.grouped_rankings = FALSE] #>      1 2 4 #> [1,] 2 1 0 #> [2,] 0 1 3"},{"path":"/reference/itempar.PlackettLuce.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Item Parameters of Plackett-Luce Models — itempar.PlackettLuce","title":"Extract Item Parameters of Plackett-Luce Models — itempar.PlackettLuce","text":"Methods itempar extract item parameters (worth log-worth) Plackett-Luce model tree. case tree, item parameters extracted terminal node.","code":""},{"path":"/reference/itempar.PlackettLuce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Item Parameters of Plackett-Luce Models — itempar.PlackettLuce","text":"","code":"# S3 method for PlackettLuce itempar(object, ref = NULL, alias = TRUE, vcov = TRUE, log = FALSE, ...)  # S3 method for pltree itempar(object, ...)  # S3 method for PLADMM itempar(object, ref = NULL, alias = TRUE, vcov = TRUE, log = FALSE, ...)"},{"path":"/reference/itempar.PlackettLuce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Item Parameters of Plackett-Luce Models — itempar.PlackettLuce","text":"object fitted model object returned PlackettLuce,  pladmm, pltree. ref vector labels position indices item parameters used restriction/normalization. NULL (default), items used zero sum (log = TRUE) unit sum (log = FALSE) constraint. alias logical. TRUE (default), aliased parameter included return vector (variance-covariance matrix vcov = TRUE). FALSE, removed. restriction given ref depends several parameters, first parameter restriction specified (arbitrarily) chosen removed alias FALSE. vcov logical. TRUE (default), (transformed) variance-covariance matrix item parameters attached attribute vcov. FALSE, NA-matrix attached. log logical. Whether return log-abilities (TRUE) abilities (FALSE). ... arguments currently used.","code":""},{"path":"/reference/itempar.PlackettLuce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Item Parameters of Plackett-Luce Models — itempar.PlackettLuce","text":"object class \"itempar\", see itempar.","code":""},{"path":"/reference/itempar.PlackettLuce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Item Parameters of Plackett-Luce Models — itempar.PlackettLuce","text":"","code":"R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\")  mod <- PlackettLuce(R) coef(mod) #>       apple      banana      orange        pear        tie2        tie3  #>  0.00000000  0.25287379 -0.61350684 -0.08688475 -2.15068111 -0.79245358   # equivalent to default coefficients, i.e. log abilities itempar(mod, ref= 1, log = TRUE) #> Item response item parameters (PlackettLuce): #>    apple   banana   orange     pear  #>  0.00000  0.25287 -0.61351 -0.08688   # abilities, normalized so abilities for apple and pear sum to 1 itempar(mod, ref = 1:2) #> Item response item parameters (PlackettLuce): #>  apple banana orange   pear  #> 0.4371 0.5629 0.2367 0.4007"},{"path":"/reference/nascar.html","id":null,"dir":"Reference","previous_headings":"","what":"Results from 2002 NASCAR Season — nascar","title":"Results from 2002 NASCAR Season — nascar","text":"example dataset Hunter 2004 recording results 36 car races 2002 NASCAR season United States. record ordering drivers according finishing position.","code":""},{"path":"/reference/nascar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results from 2002 NASCAR Season — nascar","text":"","code":"nascar"},{"path":"/reference/nascar.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results from 2002 NASCAR Season — nascar","text":"matrix 36 rows corresponding races 43 columns corresponding positions. columns contain ID driver came first last place respectively. \"drivers\" attribute contains names 87 drivers.","code":""},{"path":"/reference/nascar.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Results from 2002 NASCAR Season — nascar","text":"Hunter, D. R. (2004) MM algorithms generalized Bradley-Terry models. Annals Statistics, 32(1), 384--406.","code":""},{"path":"/reference/nascar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results from 2002 NASCAR Season — nascar","text":"","code":"# convert orderings to rankings nascar[1:2, ] #>      rank1 rank2 rank3 rank4 rank5 rank6 rank7 rank8 rank9 rank10 rank11 rank12 #> [1,]    83    18    20    48    53    51    67    72    32     42      2     31 #> [2,]    52    72     4    82    60    31    32    66     3     44      2     48 #>      rank13 rank14 rank15 rank16 rank17 rank18 rank19 rank20 rank21 rank22 #> [1,]     62     13     37      6     60     66     33     77     56     63 #> [2,]     83     67     41     77     33     61     45     38     51     14 #>      rank23 rank24 rank25 rank26 rank27 rank28 rank29 rank30 rank31 rank32 #> [1,]     55     70     14     43     71     35     12     44     79      3 #> [2,]     42     62     35     12     25     37     34      6     18     79 #>      rank33 rank34 rank35 rank36 rank37 rank38 rank39 rank40 rank41 rank42 #> [1,]     52      4      9     45     41     61     34     39     49     15 #> [2,]     39     59     43     55     49     56      9     53      7     13 #>      rank43 #> [1,]     82 #> [2,]     71 R <- as.rankings(nascar, input = \"orderings\",                  items = attr(nascar, \"drivers\")) R[1:2, 1:4, as.rankings = FALSE] #>      Austin Cameron Bill Elliott Bobby Hamilton Bobby Labonte #> [1,]              0           11             32            34 #> [2,]              0           11              9             3 format(R[1:2], width = 60) #> [1] \"Ward Burton > Elliott Sadler > Geoffrey Bodine > Kurt Bu ...\" #> [2] \"Matt Kenseth > Sterling Marlin > Bobby Labonte > Tony St ...\"  # fit model as in Hunter 2004, excluding drivers that only lose keep <- seq_len(83) R2 <- R[, keep] mod <- PlackettLuce(R2, npseudo = 0)  # show coefficients as in Table 2 of Hunter 2004 avRank <- apply(R, 2, function(x) mean(x[x > 0])) coefs <- round(coef(mod)[order(avRank[keep])], 2) head(coefs, 3) #>     PJ Jones Scott Pruett  Mark Martin  #>         4.15         3.62         2.08  tail(coefs, 3) #>  Dave Marcis Dick Trickle    Joe Varde  #>         0.03        -0.31        -0.15"},{"path":"/reference/pladmm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"Fit Plackett-Luce model log-worth predicted linear function covariates. rankings may partial (ranking completely ranks subset items), ties supported.","code":""},{"path":"/reference/pladmm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"","code":"pladmm(   rankings,   formula,   data = NULL,   weights = freq(rankings),   start = NULL,   contrasts = NULL,   rho = 1,   n_iter = 500,   rtol = 1e-04 )"},{"path":"/reference/pladmm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"rankings \"rankings\" object, object can coerced .rankings. \"aggregated_rankings\" object can used specify rankings weights simultaneously. formula formula specifying linear model log-worth. data data frame containing variables model. weights weights rankings. start starting values coefficients. contrasts optional list specifying contrasts factors formula. See contrasts.arg model.matrix(). rho penalty parameter penalized likelihood, see details. n_iter maximum number iterations (also inner loops). rtol convergence tolerance (also inner loops)","code":""},{"path":"/reference/pladmm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"log-worth modelled linear function item covariates: $$\\log \\alpha_i = \\beta_0 + \\beta_1 x_{i1} + \\ldots + \\beta_p x_{ip}$$ \\(\\beta_0\\) fixed constraint \\(\\sum_i \\alpha_i = 1\\). parameters estimated using Alternating Directions Method Multipliers (ADMM) algorithm proposed Yildiz (2020). ADMM alternates estimating worths \\(\\alpha_i\\) linear coefficients \\(\\beta_k\\), encapsulating quadratic penalty likelihood: $$L(\\boldsymbol{\\beta}, \\boldsymbol{\\alpha}, \\boldsymbol{u}) = \\mathcal{L}(\\mathcal{D}|\\boldsymbol{\\alpha}) + \\frac{\\rho}{2}||\\boldsymbol{X}\\boldsymbol{\\beta} - \\log \\boldsymbol{\\alpha} + \\boldsymbol{u}||^2_2 - \\frac{\\rho}{2}||\\boldsymbol{u}||^2_2$$ \\(\\boldsymbol{u}\\) dual variable imposes equality constraints (\\(\\log \\boldsymbol{\\alpha}\\) converges \\(\\boldsymbol{X}\\boldsymbol{\\beta}\\)).","code":""},{"path":"/reference/pladmm.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"prototype function user interface planned change upcoming versions PlackettLuce.","code":""},{"path":"/reference/pladmm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"Yildiz, ., Dy, J., Erdogmus, D., Kalpathy-Cramer, J., Ostmo, S., Campbell, J. P., Chiang, M. F. Ioannidis, S. (2020) Fast Accurate Ranking Regression Proceedings Twenty Third International Conference Artificial Intelligence Statistics, 108, 77–-88.","code":""},{"path":"/reference/pladmm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a Plackett-Luce Model with Linear Predictor for Log-worth — pladmm","text":"","code":"if (require(prefmod)){   data(salad)   # data.frame of rankings for salad dressings A B C D   # 1 = most tart, 4 = least tart   salad[1:3,]    # create data frame of corresponding features   # (acetic and gluconic acid concentrations in salad dressings)   features <- data.frame(salad = LETTERS[1:4],                          acetic = c(0.5, 0.5, 1, 0),                          gluconic = c(0, 10, 0, 10))    # fit Plackett-Luce model based on covariates   res_PLADMM <- pladmm(salad, ~ acetic + gluconic, data = features, rho = 8)   ## coefficients   coef(res_PLADMM)   ## worth   res_PLADMM$pi   ## worth as predicted by linear function   res_PLADMM$tilde_pi   ## equivalent to   drop(exp(res_PLADMM$x %*% coef(res_PLADMM)))  } #> Loading required package: prefmod #> Loading required package: gnm #> Loading required package: colorspace #>          A          B          C          D  #> 0.04060714 0.62839568 0.20874175 0.12224363"},{"path":"/reference/plfit.html","id":null,"dir":"Reference","previous_headings":"","what":"PlackettLuce Wrapper for Model-based Recursive Partitioning — plfit","title":"PlackettLuce Wrapper for Model-based Recursive Partitioning — plfit","text":"wrapper around PlackettLuce required mob model-based recursive partitioning. intended general use.","code":""},{"path":"/reference/plfit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PlackettLuce Wrapper for Model-based Recursive Partitioning — plfit","text":"","code":"plfit(   y,   x = NULL,   ref = 1L,   start = NULL,   weights = NULL,   offset = NULL,   ...,   estfun = FALSE,   object = FALSE )"},{"path":"/reference/plfit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PlackettLuce Wrapper for Model-based Recursive Partitioning — plfit","text":"y \"grouped_rankings\" object giving rankings model. x unused. ref integer character string specifying reference item (log worth set zero). NULL sum log worth parameters set zero. start starting values worth parameters tie parameters raw scale (worth parameters need scaled sum 1). normal specified, exp(normal$mu) used starting values worth parameters. Coefficients previous fit can passed result call  coef.PlackettLuce, coefficients element \"PlackettLuce\" object. weights optional vector weights ranking. offset unused. ... additional arguments passed PlackettLuce. estfun logical. TRUE empirical estimating functions (score/gradient contributions) returned. object logical. TRUE fitted model returned.","code":""},{"path":"/reference/plfit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PlackettLuce Wrapper for Model-based Recursive Partitioning — plfit","text":"list elements coefficients model coefficients. objfun negative log-likelihood. estfun estfun empirical estimating functions. object object fitted model.","code":""},{"path":"/reference/plfit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PlackettLuce Wrapper for Model-based Recursive Partitioning — plfit","text":"","code":"# rankings R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\") R <- as.rankings(R)  # group rankings into two groups G <- group(R, rep(1:2, 3))  # plfit() gives the same results as PlackettLuce() pl <- plfit(G) pl$coefficients #>       apple      banana      orange        pear        tie2        tie3  #>  0.00000000  0.25287379 -0.61350684 -0.08688475 -2.15068111 -0.79245358  -pl$objfun #> [1] -14.61069  mod <- PlackettLuce(R) coef(mod) #>       apple      banana      orange        pear        tie2        tie3  #>  0.00000000  0.25287379 -0.61350684 -0.08688475 -2.15068111 -0.79245358  logLik(mod) #> 'log Lik.' -14.61069 (df=5)"},{"path":"/reference/pltree-summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Plackett-Luce Tree Summaries — pltree-summaries","title":"Plackett-Luce Tree Summaries — pltree-summaries","text":"Obtain coefficients, variance-covariance matrix, AIC, predictions Plackett-Luce tree fitted pltree().","code":""},{"path":"/reference/pltree-summaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plackett-Luce Tree Summaries — pltree-summaries","text":"","code":"# S3 method for pltree coef(object, node = NULL, drop = TRUE, ...)  # S3 method for pltree vcov(object, node = nodeids(object, terminal = TRUE), ...)  # S3 method for pltree AIC(object, newdata = NULL, ...)  # S3 method for pltree predict(   object,   newdata = NULL,   type = c(\"itempar\", \"rank\", \"best\", \"node\"),   ... )"},{"path":"/reference/pltree-summaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plackett-Luce Tree Summaries — pltree-summaries","text":"object fitted model object class \"pltree\". node vector node ids specifying nodes summarise, default ids terminal nodes. drop TRUE return coefficients vector one node selected. ... additional arguments passed itempar predict, model.frame AIC. newdata optional data frame use instead original data. AIC must include response variable. type type prediction return group, one : \"itempar\" give result itempar (default fitted probability item ranked first objects), \"rank\" corresponding rank, \"best\" topped ranked item, \"node\" node tree group belongs .","code":""},{"path":"/reference/pltree-summaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plackett-Luce Tree Summaries — pltree-summaries","text":"AIC computes \\(-2L + 2p\\) \\(L\\) joint likelihood observed rankings tree model \\(p\\) degrees freedom used fit tree model.","code":""},{"path":"/reference/pltree-summaries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plackett-Luce Tree Summaries — pltree-summaries","text":"","code":"data(beans) # fit tree based on pairwise comparisons with variety B pairB <- data.frame(Winner = ifelse(beans$var_b == \"Worse\",                                     \"Local\", beans$variety_b),                     Loser = ifelse(beans$var_b == \"Worse\",                                    beans$variety_b, \"Local\"),                     stringsAsFactors = FALSE, row.names = NULL) beans$G <- as.rankings(pairB, input = \"orderings\",                        index = rep(seq(nrow(beans)), 1))  mod <- pltree(G ~ ., data = beans[c(\"G\", \"maxTN\")])  coef(mod, node = 3) #>      ALS 0532-6     BRT 103-182 INTA Centro Sur    INTA Ferroso  INTA Matagalpa  #>      0.00000000     -0.07161137      0.14990568     -0.16583159     -0.48272277  #>     INTA Precoz       INTA Rojo     INTA Sequia           Local     PM2 Don Rey  #>     -0.03697466     -0.68305444     -0.43665252     -0.31973562      0.54722786  #>      SJC 730-79  #>     -0.37766352  AIC(mod) #> [1] 1123.72  # treat first row from each year as new data newdata <- beans[!duplicated(beans$year),]  ## fitted probabilities predict(mod, newdata) #>     ALS 0532-6 BRT 103-182 INTA Centro Sur INTA Ferroso INTA Matagalpa #> 1   0.10191465  0.09487159      0.11839676   0.08634096     0.06289162 #> 482 0.09663466  0.09072365      0.04497423   0.09188975     0.09950195 #>     INTA Precoz  INTA Rojo INTA Sequia      Local PM2 Don Rey SJC 730-79 #> 1    0.09821520 0.05147423  0.06585683 0.07402479  0.17615486 0.06985853 #> 482  0.08239922 0.08743950  0.13071479 0.16470103  0.04214223 0.06887900  ## fitted log-abilities, with Local as reference predict(mod, newdata, log = TRUE, ref = \"Local\") #>     ALS 0532-6 BRT 103-182 INTA Centro Sur INTA Ferroso INTA Matagalpa #> 1    0.3197356   0.2481243       0.4696413    0.1539040     -0.1629871 #> 482 -0.5331945  -0.5963139      -1.2980422   -0.5835425     -0.5039546 #>     INTA Precoz  INTA Rojo INTA Sequia Local PM2 Don Rey SJC 730-79 #> 1     0.2827610 -0.3633188  -0.1169169     0   0.8669635 -0.0579279 #> 482  -0.6925559 -0.6331848  -0.2311141     0  -1.3630816 -0.8717806  ## variety ranks predict(mod, newdata, type = \"rank\") #>     ALS 0532-6 BRT 103-182 INTA Centro Sur INTA Ferroso INTA Matagalpa #> 1            3           5               2            6             10 #> 482          4           6              10            5              3 #>     INTA Precoz INTA Rojo INTA Sequia Local PM2 Don Rey SJC 730-79 #> 1             4        11           9     7           1          8 #> 482           8         7           2     1          11          9  ## top ranked variety predict(mod, newdata, type = \"best\") #>             1           482  #> \"PM2 Don Rey\"       \"Local\"   ## node the trial belongs to predict(mod, newdata, type = \"node\") #>   1   2  #> \"3\" \"2\""},{"path":"/reference/pltree.html","id":null,"dir":"Reference","previous_headings":"","what":"Plackett-Luce Trees — pltree","title":"Plackett-Luce Trees — pltree","text":"Recursive partitioning based Plackett-Luce models.","code":""},{"path":"/reference/pltree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plackett-Luce Trees — pltree","text":"","code":"pltree(formula, data, worth, na.action, cluster, ref = NULL, ...)"},{"path":"/reference/pltree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plackett-Luce Trees — pltree","text":"formula symbolic description model fitted, form y ~ x1 + ... + xn y object class grouped_rankings x1, ..., xn used partitioning variables. data optional data object containing variables model. Either data frame variables formula list length 2 giving data frames variables formula worth. worth optional formula specifying linear model log-worth. NULL, worth estimated separately item PlackettLuce(). Otherwise, model node tree id fitted pladmm(). na.action NAs treated variables formula, applied underlying rankings. cluster optional vector cluster IDs employed clustered covariances parameter stability tests, see mob. ref integer character string specifying reference item (log ability set zero). NULL first item used. ... additional arguments, passed PlackettLuce pladmm().","code":""},{"path":"/reference/pltree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plackett-Luce Trees — pltree","text":"object class \"pltree\" inheriting \"bttree\" \"modelparty\".","code":""},{"path":"/reference/pltree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plackett-Luce Trees — pltree","text":"Plackett-Luce trees application model-based recursive partitioning (implemented mob) Plackett-Luce models rankings. partitioning based ranking covariates, e.g. attributes judge making ranking, conditions ranking made. response grouped_rankings object groups rankings common covariate values. may included data frame alongside covariates. arguments PlackettLuce can passed pltree. However, Plackett-Luce tree fixed adherence implemented. Arguably makes sense estimate adherence reliability within nodes Plackett-Luce tree. Various methods provided \"pltree\" objects, inherited \"modelparty\" objects (e.g. print, summary), \"bttree\" objects (plot). plot method employs node_btplot panel-generating function. See Also section gives details separately documented methods.","code":""},{"path":[]},{"path":"/reference/pltree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plackett-Luce Trees — pltree","text":"","code":"# Bradley-Terry example  if (require(psychotree)){     ## Germany's Next Topmodel 2007 data     data(\"Topmodel2007\", package = \"psychotree\")     ## convert paircomp object to grouped rankings     R <- as.grouped_rankings(Topmodel2007$preference)     ## rankings are grouped by judge     print(R[1:2,], max = 4)     ## Topmodel2007[, -1] gives covariate values for each judge     print(Topmodel2007[1:2, -1])      ## fit partition model based on all variables except preference     ## set npseudo = 0 as all judges rank all models     tm_tree <- pltree(R ~ ., data = Topmodel2007[, -1], minsize = 5,                       npseudo = 0)      ## plot shows abilities constrained to sum to 1     plot(tm_tree, abbreviate = 1, yscale = c(0, 0.5))     ## instead show log-abilities with Anja as reference (need to used index)     plot(tm_tree, abbreviate = 1, worth = FALSE, ref = 6,          yscale = c(-1.5, 2.2))      ## log-abilities, zero sum contrast     itempar(tm_tree, log = TRUE) } #> Loading required package: psychotree #> Loading required package: partykit #> Loading required package: grid #> Loading required package: libcoin #> Loading required package: mvtnorm #> Loading required package: psychotools #>                                                                   1  #> \"Barbara > Anni, Barbara > Hana, Anni > Hana, Barbara > Fiona, ...\"  #>                                                                   2  #> \"Anni > Barbara, Hana > Barbara, Hana > Anni, Fiona > Barbara, ...\"  #>   gender age  q1  q2  q3 #> 1   male  66  no  no  no #> 2   male  21 yes yes yes   #>     Barbara       Anni       Hana      Fiona       Mandy       Anja #> 3 0.3252815  0.2193055 1.03734300 -0.1785927 -0.39080852 -1.0125288 #> 5 0.1106734 -0.2392155 0.51830152  0.3662483 -0.42801793 -0.3279899 #> 6 0.5715647  0.3486194 0.06927133  0.2590188 -0.87250734 -0.3759669 #> 7 0.5343475 -1.0000476 0.01067104  0.0575107  0.08093274  0.3165856"},{"path":"/reference/preflib.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Preflib Election Data Files — preflib","title":"Read Preflib Election Data Files — preflib","text":"Read orderings .soc, .soi, .toc .toi file types storing election data defined {PrefLib}: Library Preferences.","code":""},{"path":"/reference/preflib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Preflib Election Data Files — preflib","text":"","code":"read.soc(file)  read.soi(file)  read.toc(file)  read.toi(file)  # S3 method for preflib as.aggregated_rankings(x, ...)"},{"path":"/reference/preflib.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read Preflib Election Data Files — preflib","text":"file election data file, conventionally extension .soc, .soi, .toc .toi according data type. x object class \"preflib\". ... Additional arguments passed .rankings(): freq, input items ignored warning set automatically.","code":""},{"path":"/reference/preflib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Preflib Election Data Files — preflib","text":"data frame class \"preflib\" first column Freq, giving frequency ranking row, remaining columns Rank 1, ..., Rank p giving items ranked first last place ranking. Ties represented vector elements list columns. data frame attribute \"items\" giving labels corresponding item number.","code":""},{"path":"/reference/preflib.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read Preflib Election Data Files — preflib","text":"file types supported .soc Strict Orders - Complete List .soi Strict Orders - Incomplete List .toc Orders Ties - Complete List .toi Orders Ties - Incomplete List Note file types distinguish types incomplete orderings, .e. whether complete ranking subset items (supported PlackettLuce()) top-\\(n\\) rankings \\(n\\) items full set items (currently supported PlackettLuce()). numerically coded orderings frequencies read data frame, storing item names attribute. .aggregated_rankings method converts \"aggregated_rankings\" object items labelled item names. Preflib file may corrupt, sense ordered items match named items. case, file can read data frame (warning) using corresponding read.* function, .aggregated_rankings throw error.","code":""},{"path":"/reference/preflib.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Read Preflib Election Data Files — preflib","text":"Netflix cities datasets used examples Caragiannis et al (2017) Bennet Lanning (2007) respectively. data sets require citation re-use.","code":""},{"path":"/reference/preflib.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Read Preflib Election Data Files — preflib","text":"Mattei, N. Walsh, T. (2013) PrefLib: Library Preference Data. Proceedings Third International Conference Algorithmic Decision Theory (ADT 2013). Lecture Notes Artificial Intelligence, Springer. Caragiannis, ., Chatzigeorgiou, X, Krimpas, G. ., Voudouris, . . (2017) Optimizing positional scoring rules rank aggregation. Proceedings 31st AAAI Conference Artificial Intelligence. Bennett, J. Lanning, S. (2007) Netflix Prize. Proceedings KDD Cup Workshops.","code":""},{"path":"/reference/preflib.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Preflib Election Data Files — preflib","text":"","code":"# can take a little while depending on speed of internet connection  if (FALSE) { # url for preflib data in the \"Election Data\" category preflib <- \"https://www.preflib.org/static/data/ED/\"  # strict complete orderings of four films on Netflix netflix <- read.soc(file.path(preflib, \"netflix/ED-00004-00000101.soc\")) head(netflix) attr(netflix, \"items\")  head(as.rankings(netflix))  # strict incomplete orderings of 6 random cities from 36 in total cities <- read.soi(file.path(preflib, \"cities/ED-00034-00000001.soi\"))  # strict incomplete orderings of drivers in the 1961 F1 races # 8 races with 17 to 34 drivers in each f1 <- read.soi(file.path(preflib, \"f1/ED-00010-00000001.soi\"))  # complete orderings with ties of 30 skaters skaters <- read.toc(file.path(preflib, \"skate/ED-00006-00000001.toc\"))  # incomplete orderings with ties of 10 sushi items from 100 total # orderings were derived from numeric ratings sushi <- read.toi(file.path(preflib, \"sushi/ED-00014-00000003.toi\")) }"},{"path":"/reference/pudding.html","id":null,"dir":"Reference","previous_headings":"","what":"Paired Comparisons of Chocolate Pudding — pudding","title":"Paired Comparisons of Chocolate Pudding — pudding","text":"example dataset Davidson 1970 comprising paired comparisons chocolate pudding, six brands total. responses include tied outcomes, .e. preference.","code":""},{"path":"/reference/pudding.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Paired Comparisons of Chocolate Pudding — pudding","text":"","code":"pudding"},{"path":"/reference/pudding.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Paired Comparisons of Chocolate Pudding — pudding","text":"data frame 15 records 6 variables: first brand comparison. j second brand comparison. r_ij frequency paired comparisons brand brand j. w_ij frequency preferences j. w_ji frequency preferences j . t_ij frequency preference j.","code":""},{"path":"/reference/pudding.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Paired Comparisons of Chocolate Pudding — pudding","text":"Davidson, R. R. (1970). extending Bradley-Terry model accommodate ties paired comparison experiments. Journal American Statistical Association, 65, 317--328.","code":""},{"path":"/reference/pudding.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Paired Comparisons of Chocolate Pudding — pudding","text":"","code":"# create orderings for each set of paired comparisons  # wins for brand i and wins for brand j i_wins <- data.frame(Winner = pudding$i, Loser = pudding$j) j_wins <- data.frame(Winner = pudding$j, Loser = pudding$i)  # ties: use an array list (easier with R >= 3.6.0) if (getRversion() < \"3.6.0\"){   n <- nrow(pudding)   ties <- data.frame(Winner = array(split(pudding[c(\"i\", \"j\")], 1:n), n),                      Loser = rep(NA, 15)) } else {   ties <- data.frame(Winner = asplit(pudding[c(\"i\", \"j\")], 1),                      Loser = rep(NA, 15)) } head(ties, 2) #>   Winner Loser #> 1   1, 2    NA #> 2   1, 3    NA  # convert to rankings R <- as.rankings(rbind(i_wins, j_wins, ties),                  input = \"orderings\") head(R, 2) #> [1] \"1 > 2\" \"1 > 3\" tail(R, 2) #> [1] \"4 = 6\" \"5 = 6\"  # define weights as frequencies of each ranking w <- unlist(pudding[c(\"w_ij\", \"w_ji\", \"t_ij\")])  # fit Plackett-Luce model: limit iterations to match paper mod <- PlackettLuce(R, npseudo = 0, weights = w, maxit = 7) #> Warning: Iterations have not converged."},{"path":"/reference/qvcalc.PlackettLuce.html","id":null,"dir":"Reference","previous_headings":"","what":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"method qvcalc compute set quasi variances (corresponding quasi standard errors) estimated item parameters Plackett-Luce model.","code":""},{"path":"/reference/qvcalc.PlackettLuce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"","code":"# S3 method for PlackettLuce qvcalc(object, ref = 1L, ...)"},{"path":"/reference/qvcalc.PlackettLuce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"object \"PlackettLuce\" object returned PlackettLuce. ref integer character string specifying reference item (log worth set zero). NULL sum log worth parameters set zero. ... additional arguments, currently ignored..","code":""},{"path":"/reference/qvcalc.PlackettLuce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"list class \"qv\", components covmat full variance-covariance matrix item parameters. qvframe data frame variables estimate, SE, quasiSE quasiVar, last two quasi standard error quasi-variance parameter. dispersion NULL (dispersion fixed 1). relerrs Relative errors approximating standard errors simple contrasts. factorname NULL (required method). coef.indices NULL (required method). modelcall call PlackettLuce fit model item parameters estimated.","code":""},{"path":"/reference/qvcalc.PlackettLuce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"details method see Firth (2000), Firth (2003) Firth de Menezes (2004). Quasi variances generalize improve accuracy “floating absolute risk” (Easton et al., 1991). device economical model summary first suggested Ridout (1989). Ordinarily quasi variances positive square roots (quasi standard errors) exist can used plots, etc.","code":""},{"path":"/reference/qvcalc.PlackettLuce.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"Easton, D. F, Peto, J. Babiker, . G. . G. (1991) Floating absolute risk: alternative relative risk survival case-control analysis avoiding arbitrary reference group. Statistics Medicine 10, 1025--1035. Firth, D. (2000)  Quasi-variances Xlisp-Stat web. Journal Statistical Software 5.4, 1--13. https://www.jstatsoft.org Firth, D. (2003) Overcoming reference category problem presentation statistical models. Sociological Methodology 33, 1--18. Firth, D. de Menezes, R. X. (2004)  Quasi-variances. Biometrika 91, 65--80. Menezes, R. X. de (1999)  useful standard errors group factor effects generalized linear models.  D.Phil. Thesis, Department Statistics, University Oxford. Ridout, M.S. (1989). Summarizing results fitting generalized linear models data designed experiments. : Statistical Modelling: Proceedings GLIM89 4th International Workshop Statistical Modelling held Trento, Italy, July 17--21, 1989 (. Decarli et al., eds.), pp 262--269. New York: Springer.","code":""},{"path":[]},{"path":"/reference/qvcalc.PlackettLuce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quasi Variances for Model Coefficients — qvcalc.PlackettLuce","text":"","code":"# Six partial rankings of four objects, 1 is top rank, e.g # first ranking: item 1, item 2 # second ranking: item 2, item 3, item 4, item 1 # third ranking: items 2, 3, 4 tie for first place, item 1 second R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\")  mod <- PlackettLuce(R) qv <- qvcalc(mod) qv #>           estimate       SE   quasiSE  quasiVar #> apple   0.00000000 0.000000 0.6655053 0.4428973 #> banana  0.25287379 1.042049 0.8372194 0.7009362 #> orange -0.61350684 1.115181 0.8320735 0.6923463 #> pear   -0.08688475 1.067688 0.8632849 0.7452608 plot(qv)"},{"path":"/reference/rankings.html","id":null,"dir":"Reference","previous_headings":"","what":"Rankings Object — rankings","title":"Rankings Object — rankings","text":"Create \"rankings\" object data convert matrix rankings ordered items \"rankings\" object.","code":""},{"path":"/reference/rankings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rankings Object — rankings","text":"","code":"rankings(data, id, item, rank, aggregate = FALSE, verbose = TRUE, ...)  as.rankings(x, ..., verbose = TRUE)  # S3 method for default as.rankings(   x,   input = c(\"rankings\", \"orderings\"),   freq = NULL,   index = NULL,   aggregate = FALSE,   items = NULL,   labels = NULL,   ...,   verbose = TRUE )  # S3 method for grouped_rankings as.rankings(x, ..., verbose = TRUE)  # S3 method for matrix as.rankings(   x,   input = c(\"rankings\", \"orderings\"),   freq = NULL,   index = NULL,   aggregate = FALSE,   items = NULL,   labels = NULL,   ...,   verbose = TRUE )  # S3 method for rankings [(x, i, j, ..., drop = TRUE, as.rankings = TRUE)  # S3 method for rankings format(x, width = 40L, ...)"},{"path":"/reference/rankings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rankings Object — rankings","text":"data data frame columns specified id, item rank. id index data specifying column containing ranking IDs. item index data specifying column containing item IDs, rank index data specifying column containing item ranks. aggregate TRUE, aggregate rankings via aggregate() returning. verbose logical; TRUE print messages changes made rankings data. ... arguments passed /methods. x .rankings, matrix one column per item one row per ranking, object can coerced matrix; [ format, \"rankings\" object. input .rankings, whether rows input matrix contain numeric \"rankings\" (dense, standard/modified competition fractional rankings) \"orderings\", .e. items ordered rank. freq optional column index (number, character logical) specifying column x holds ranking frequencies, vector ranking frequencies. provided, \"aggregated_rankings\" object returned. index optional column index (number, character logical) specifying column x holds grouping index, numeric vector grouping. provided, rankings grouped group() returning. items input = \"orderings\", character vector specifying full set items. Values x matched value (character) position (numeric). Use decode() orderings requiring complex decoding. labels input = \"orderings\" optional vector labels items, corresponding sorted unique values x. indices specifying rankings extract, [. j indices specifying items extract, [. drop TRUE return single row/column matrices vector. .rankings TRUE return rankings object, otherwise return matrix/vector. width width number characters format ranking - rankings wide truncated.","code":""},{"path":"/reference/rankings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rankings Object — rankings","text":"default, \"rankings\" object, matrix dense rankings methods several generics including aggregate, [, format, rbind() .matrix(). object created aggregate = TRUE, ranking frequencies specified via freq, rankings post-processed create \"aggregated_rankings\" object. group index specified via index, (possibly aggregated) rankings post-processed create \"grouped_rankings\" object.","code":""},{"path":"/reference/rankings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rankings Object — rankings","text":"ranking input data converted dense ranking, rank items 1 (first place) \\(n_r\\) (last place). Items ranked rank 0 NA. Tied items given rank rank skipped. example 1, 0, 2, 1, ranks first fourth items first place third item second place; second item unranked. Records data missing id item dropped. Duplicated items rankings resolved possible: redundant inconsistent ranks set NA. Rankings 1 item set NA (rankings zero items automatically treated NA). issues causing records removed recoded produce message verbose = TRUE. .rankings input = \"orderings\", unused ranks may filled zeroes numeric x NA. necessary many columns ranks used. method [ return reduced rankings object default, recoding dense rankings setting invalid rankings NA necessary. extract rows /columns rankings matrix vector, set .rankings = FALSE, see examples.","code":""},{"path":"/reference/rankings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rankings Object — rankings","text":"","code":"# create rankings from data in long form  # example long form data x <- data.frame(ranking = c(rep(1:4, each = 4), 5, 5, 5),                 letter = c(LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,                            LETTERS[3:5]),                 rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3))  # ranking 1 has different rank for same item, but order of items unambiguous # all ranks are missing in ranking 2 # some ranks are missing in ranking 3 # ranking 4 has inconsistent ranks for two items and a rank with missing item # ranking 5 is fine - an example of a tie split(x, x$ranking) #> $`1` #>   ranking letter rank #> 1       1      A    4 #> 2       1      B    3 #> 3       1      C    2 #> 4       1      C    1 #>  #> $`2` #>   ranking letter rank #> 5       2      A   NA #> 6       2      B   NA #> 7       2      C   NA #> 8       2      D   NA #>  #> $`3` #>    ranking letter rank #> 9        3      B    3 #> 10       3      C    4 #> 11       3      D   NA #> 12       3      E   NA #>  #> $`4` #>    ranking letter rank #> 13       4      A    1 #> 14       4      B    3 #> 15       4      A    4 #> 16       4   <NA>    2 #>  #> $`5` #>    ranking letter rank #> 17       5      C    2 #> 18       5      D    2 #> 19       5      E    3 #>   # fix issues when creating rankings object rankings(x, id = \"ranking\", item = \"letter\", rank = \"rank\") #> Removed records with unknown id or item #> Duplicated items within rankings: set redundant/inconsistent to `NA`. #> Recoded rankings that are not in dense form #> Rankings with only 1 item set to `NA` #>           1           2           3           4           5  #>     \"B > A\"          NA     \"B > C\"          NA \"C = D > E\"   # convert existing matrix of rankings  R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\") R <- as.rankings(R)  # first three rankings R[1:3,] #> [1] \"apple > banana\"                 \"banana > orange > pear > apple\" #> [3] \"banana = orange = pear > apple\"  # exclude pear from the rankings R[, -4] #> Recoded rankings that are not in dense form #> [1] \"apple > banana\"          \"banana > orange > apple\" #> [3] \"banana = orange > apple\" \"apple > banana > orange\" #> [5] \"banana = orange > apple\" \"apple > orange\"           # extract rankings 2 and 3 as numeric matrix R[2:3, , as.rankings = FALSE] #>      apple banana orange pear #> [1,]     4      1      2    3 #> [2,]     2      1      1    1  # same as as.matrix(R)[2:3,] #>      apple banana orange pear #> [1,]     4      1      2    3 #> [2,]     2      1      1    1  # extract rankings for item 1 as a vector R[,1, as.rankings = FALSE] #> [1] 1 4 2 1 2 1"},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. psychotools itempar qvcalc qvcalc utils str","code":""},{"path":"/reference/simulate.PlackettLuce.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"Simulate PlackettLuce fitted objects","code":""},{"path":"/reference/simulate.PlackettLuce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"","code":"# S3 method for PlackettLuce simulate(   object,   nsim = 1L,   seed = NULL,   multinomial = FALSE,   max_combinations = 20000,   ... )"},{"path":"/reference/simulate.PlackettLuce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"object object representing fitted model. nsim number response vectors simulate.  Defaults 1. seed object specifying random number generator initialised. Either NULL integer used call set.seed simulating rankings. set, value saved seed attribute returned value.  default, NULL, change random generator state, return .Random.seed seed attribute. multinomial use multinomial sampling anyway? Default FALSE. see Details. max_combinations positive number. Default 20000. See Details. ... additional optional arguments.","code":""},{"path":"/reference/simulate.PlackettLuce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"data.frame rankings objects dimension object$rankings.","code":""},{"path":"/reference/simulate.PlackettLuce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"multinomial FALSE (default) tie parameters object (.e. length(object$ties) == 1), rankings sampled ordering exponential random variates rate 1 scaled estimated item-worth parameters object$coefficients (see, Diaconis, 1988, Chapter 9D details). cases, current implementation uses direct multinomial sampling, throw error max_combinations combinations items sampler decide . hard-coded exit prevent issues relating creation massive objects memory. length(object$ties) > 1 user's setting multinomial ignored simulate.PlackettLuce operates multinomial TRUE.","code":""},{"path":"/reference/simulate.PlackettLuce.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"Diaconis (1988). Group Representations Probability Statistics. Institute Mathematical Statistics Lecture Notes 11. Hayward, CA.","code":""},{"path":"/reference/simulate.PlackettLuce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from PlackettLuce fitted objects — simulate.PlackettLuce","text":"","code":"R <- matrix(c(1, 2, 0, 0,               4, 1, 2, 3,               2, 1, 1, 1,               1, 2, 3, 0,               2, 1, 1, 0,               1, 0, 3, 2), nrow = 6, byrow = TRUE) colnames(R) <- c(\"apple\", \"banana\", \"orange\", \"pear\") mod <- PlackettLuce(R) simulate(mod, 5) #>                            sim_1                          sim_2 #> 1                 apple > banana                 apple > banana #> 2 pear > banana > apple > orange banana > pear > apple > orange #> 3 pear > banana > apple > orange banana > apple = orange = pear #> 4        apple = banana > orange        apple = banana > orange #> 5        banana > apple > orange        orange > banana > apple #> 6          apple > pear > orange          apple > pear > orange #>                            sim_3                          sim_4 #> 1                 banana > apple                 banana > apple #> 2 orange > apple > banana > pear apple > banana > pear > orange #> 3 orange > banana = pear > apple pear > apple = banana = orange #> 4        apple > banana > orange        banana > apple > orange #> 5        apple > banana > orange        banana > orange > apple #> 6          pear > apple > orange          orange > apple > pear #>                            sim_5 #> 1                 apple > banana #> 2 pear > banana > apple = orange #> 3 apple = orange = pear > banana #> 4        banana > apple > orange #> 5        banana > apple = orange #> 6          pear > apple > orange  s1 <- simulate(mod, 3, seed = 112) s2 <- simulate(mod, 2, seed = 112)  identical(s1[1:2], s2[1:2]) #> [1] TRUE"},{"path":"/reference/summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Plackett-Luce Model Summaries — summaries","title":"Plackett-Luce Model Summaries — summaries","text":"Obtain coefficients, model summary coefficient variance-covariance matrix model fitted PlackettLuce.","code":""},{"path":"/reference/summaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plackett-Luce Model Summaries — summaries","text":"","code":"# S3 method for PlackettLuce coef(object, ref = 1L, log = TRUE, type = \"all\", ...)  # S3 method for PlackettLuce summary(object, ref = 1L, ...)  # S3 method for PlackettLuce vcov(object, ref = 1L, type = c(\"expected\", \"observed\"), ...)"},{"path":"/reference/summaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plackett-Luce Model Summaries — summaries","text":"object object class \"PlackettLuce\" returned PlackettLuce. ref integer character string specifying reference item (log worth set zero). NULL sum log worth parameters set zero. log logical indicating whether return parameters log scale item specified ref set zero. type coef, type coefficients return: one \"ties\", \"worth\" \"\". vcov, type Fisher information base estimation : either \"expected\" \"observed\". ... additional arguments, passed vcov summary.","code":""},{"path":"/reference/summaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plackett-Luce Model Summaries — summaries","text":"default, parameters returned log scale, suited inference. log = FALSE, worth parameters returned, constrained sum one represent probability corresponding item comes first ranking items, given first place tied. variance-covariance matrix returned worth tie parameters log scale, reference specified ref. models estimated maximum likelihood, variance-covariance inverse Fisher information log-likelihood. models normal gamma prior, variance-covariance based Fisher information log-posterior. adherence parameters estimated, log-posterior linear parameters. case difference expected observed Fisher information. default, vcov return variance-covariance based expected information, type gives option use observed information instead. large samples, difference options small. Note estimation adherence parameters accounted computation variance-covariance matrix, sub-matrix corresponding worth tie parameters estimated.","code":""},{"path":"/news/index.html","id":"plackettluce-042","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.4.2","title":"PlackettLuce 0.4.2","text":"Fix test broken survival update.","code":""},{"path":"/news/index.html","id":"plackettluce-041","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.4.1","title":"PlackettLuce 0.4.1","text":"CRAN release: 2021-08-16","code":""},{"path":"/news/index.html","id":"new-features-0-4-1","dir":"Changelog","previous_headings":"","what":"New features","title":"PlackettLuce 0.4.1","text":"Extend pltree allow option modelling log-worth linear predictor (via pladmm()). Improved handling model formula pladmm(), including possibility specify contrasts factors formula. Add anova method PLADMM models. Add weights argument pladmm(), allowing aggregated rankings modelled, optionally using aggregate_rankings object specify rankings weights together.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-4-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"PlackettLuce 0.4.1","text":"Avoid computing variance-covariance matrix predict.PLADMM(vcov = FALSE) AIC new data specified (partial fix #50). Correct residual df PLADMM models based partial rankings (previously assumed rankings equal number items). Update URL Preflib data sets.","code":""},{"path":"/news/index.html","id":"plackettluce-040","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.4.0","title":"PlackettLuce 0.4.0","text":"CRAN release: 2021-03-29 New pladmm function fit Plackett-Luce model log-worth modelled item covariates. Add three new variables beans data. planting date, geographical coordinates (@kauedesousa, #41).","code":""},{"path":"/news/index.html","id":"plackettluce-032","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.3.2","title":"PlackettLuce 0.3.2","text":"CRAN release: 2021-01-04 Fix test fails new behaviour .equal(). Update citation use Computational Statistics paper (#44).","code":""},{"path":"/news/index.html","id":"plackettluce-031","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.3.1","title":"PlackettLuce 0.3.1","text":"CRAN release: 2020-10-13 Fix Preflib URL.","code":""},{"path":"/news/index.html","id":"plackettluce-030","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.3.0","title":"PlackettLuce 0.3.0","text":"Now correctly handles cases intermediate tie orders observed, fixing corresponding tie parameters zero (#42).","code":""},{"path":"/news/index.html","id":"plackettluce-02-9","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-9","title":"PlackettLuce 0.2-9","text":"CRAN release: 2019-09-16 vcov.PlackettLuce() works ref = NULL (bug introduced vcov method version 0.2-4) avoid dependency R >= 3.6.0 providing alternatives asplit() read.soi() read.toi() now handle incomplete rankings irregular lengths correctly. read.*() functions Preflib formats now give meaningful error file URL exist, warning file corrupt. .rankings input = \"orderings\" now checks coded values can matched item names, provided. PlackettLuce() now works nspeudo > 0 observed paired comparisons. ?PlackettLuce now gives advice analysing data higher order ties.","code":""},{"path":"/news/index.html","id":"plackettluce-02-8","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-8","title":"PlackettLuce 0.2-8","text":"CRAN release: 2019-09-05 Fix bug .rankings.matrix() introduced version 0.2-7. Import eigs RSpectra vs rARPACK.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-2-7","dir":"Changelog","previous_headings":"","what":"New Features","title":"PlackettLuce 0.2-7","text":"New \"aggregated_rankings\" object store aggregated rankings corresponding frequencies. Objects class \"rankings\" can aggregated via aggregate method; alternatively rankings() .rankings() create \"aggregated_rankings\" object aggregate = TRUE. .rankings() also handles pre-aggregated data, accepting frequencies via freq argument. New freq() function extract frequencies aggregated rankings. .rankings() can now create \"grouped_rankings\" object, grouping index passed via index argument. New .matrix() methods rankings aggregated rankings extract underlying matrix rankings, frequencies final column relevant. means rankings can saved easily write.table(). New complete() decode() functions help pre-process orderings converting rankings, complete() infers item(s) r’th rank given items (r - 1) ranks. decode() converts coded (partial) orderings orderings items ordering. New read.soi(), read.toc() read.toi() read corresponding PrefLib file formats (data types “Strict Orders - Incomplete List”, “Orders Ties - Complete List” “Orders Ties - Incomplete List”). .aggregated_rankings() method provided convert data frame aggregated orderings \"aggregated_rankings\" object.","code":""},{"path":"/news/index.html","id":"improvements-0-2-7","dir":"Changelog","previous_headings":"","what":"Improvements","title":"PlackettLuce 0.2-7","text":"pltree() now respects na.action pad predictions fitted values na.action = \"na.exclude\" rankings missing whole group one model covariates missing value. PlackettLuce() now na.action argument handling missing rankings. fitted() choices() now return data frames, list columns necessary.","code":""},{"path":"/news/index.html","id":"changes-in-behaviour-0-2-7","dir":"Changelog","previous_headings":"","what":"Changes in behaviour","title":"PlackettLuce 0.2-7","text":"rankings() now sets redundant/inconsistent ranks NA rather dropping . affect final ranking, unless completely NA. frequencies column data frame returned read.soc() now named Freq rather n. \"item\" attribute data frame returned read.soc() now named \"items\". labels argument .rankings() deprecated replaced items. grouped_ranking() deprecated replaced group(). redundant columns nascar data dropped.","code":""},{"path":"/news/index.html","id":"plackettluce-02-6","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-6","title":"PlackettLuce 0.2-6","text":"CRAN release: 2019-04-01 Avoid using isFALSE() compatibility R < 3.5. Don’t test number iterations comparing models grouped ungrouped rankings.","code":""},{"path":"/news/index.html","id":"plackettluce-02-5","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-5","title":"PlackettLuce 0.2-5","text":"CRAN release: 2019-03-20 Higher tolerance tests vcov() CRAN Windows test machine.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-2-4","dir":"Changelog","previous_headings":"","what":"New Features","title":"PlackettLuce 0.2-4","text":"PlackettLuce() now supports MAP estimation multivariate normal prior log-worths /gamma prior ranker adherence. PlackettLuce() now returns log-likelihood degrees freedom null model (outcomes, including ties, equal probability). now vcov method Plackett-Luce trees.","code":""},{"path":"/news/index.html","id":"changes-in-behaviour-0-2-4","dir":"Changelog","previous_headings":"","what":"Changes in Behaviour","title":"PlackettLuce 0.2-4","text":"itempar.PlackettLuce() now always returns matrix, even single node tree.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-2-4","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"PlackettLuce 0.2-4","text":"pltree() PlackettLuce() grouped rankings now work correctly weights.","code":""},{"path":"/news/index.html","id":"plackettluce-02-3","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-3","title":"PlackettLuce 0.2-3","text":"CRAN release: 2018-04-09","code":""},{"path":"/news/index.html","id":"improvements-0-2-3","dir":"Changelog","previous_headings":"","what":"Improvements","title":"PlackettLuce 0.2-3","text":"Print methods \"PlackettLuce\" \"summary.PlacketLuce\" objects now respect options(\"width\").","code":""},{"path":"/news/index.html","id":"changes-in-behaviour-0-2-3","dir":"Changelog","previous_headings":"","what":"Changes in Behaviour","title":"PlackettLuce 0.2-3","text":"fitted always returns n now weighted count rankings (previously returned unweighted count argument aggregate = TRUE).","code":""},{"path":"/news/index.html","id":"bug-fixes-0-2-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"PlackettLuce 0.2-3","text":"Correct vcov weighted rankings two items. Enable AIC.pltree work \"pltree\" object one node.","code":""},{"path":"/news/index.html","id":"plackettluce-02-2","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-2","title":"PlackettLuce 0.2-2","text":"CRAN release: 2018-02-19","code":""},{"path":"/news/index.html","id":"new-features-0-2-2","dir":"Changelog","previous_headings":"","what":"New features","title":"PlackettLuce 0.2-2","text":"Add AIC.pltree enable computation AIC new observations (e.g. data held cross-validation). Add fitted.pltree return combined fitted probabilities choice within ranking, node Plackett-Luce tree.","code":""},{"path":"/news/index.html","id":"bug-fixes-0-2-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"PlackettLuce 0.2-2","text":"vcov.PlackettLuce now works models non-integer weights (fixes #25). plot.pltree now works worth = TRUE psychotree version 0.15-2 (currently pre-release https://r-forge.r-project.org/R/?group_id=330) PlackettLuce plfit now work start argument set. itempar.PlackettLuce now works alias = FALSE","code":""},{"path":"/news/index.html","id":"plackettluce-02-1","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.2-1","title":"PlackettLuce 0.2-1","text":"CRAN release: 2017-12-07","code":""},{"path":"/news/index.html","id":"new-features-0-2-1","dir":"Changelog","previous_headings":"","what":"New features","title":"PlackettLuce 0.2-1","text":"Add pkgdown site. Add content README (fixes #5). Add plot.PlackettLuce method plotting works saved \"PlackettLuce\" object","code":""},{"path":"/news/index.html","id":"improvements-0-2-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"PlackettLuce 0.2-1","text":"Improved vignette, particularly example based beans data (updated). Improved help files particularly ?PlackettLuce new package?PlackettLuce. (Fixes #14 #21).","code":""},{"path":"/news/index.html","id":"changes-in-behaviour-0-2-1","dir":"Changelog","previous_headings":"","what":"Changes in behaviour","title":"PlackettLuce 0.2-1","text":"maxit defaults 500 PlackettLuce. Steffensen acceleration applied iterations increase log-likelihood (still attempted iterations reached solution “close enough” specified steffensen argument).","code":""},{"path":"/news/index.html","id":"bug-fixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"PlackettLuce 0.2-1","text":"coef.pltree() now respects log = TRUE argument (fixes #19). Fix bug causes lack convergence iterative scaling plus pseudo-rankings. [.grouped_rankings] now works replicated indices.","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"PlackettLuce 0.2-0","text":"Add vignette. Add data sets pudding, nascar beans. Add pltree() function use partykit::mob(). Requires new objects type \"grouped_rankings\" add grouping index \"rankings\" object store derived objects used PlackettLuce. Methods print, plot predict Plackett-Luce tree provided. Add connectivity() function check connectivity network given adjacency matrix. New adjacency() function computes adjacency matrix without creating edgelist, remove .edgelist generic method `“PlackettLuce” objects. Add .data.frame methods rankings grouped rankings can added model frames. Add format methods rankings grouped_rankings, pretty printing. Add [ methods rankings grouped_rankings, create valid rankings selected rankings /items. Add method argument offer choices iterative scaling (default), direct maximisation likelihood via BFGS L-BFGS. Add itempar method “PlackettLuce” objects obtain different parameterizations worth parameters. Add read.soc function read Strict Orders - Complete List (.soc) files https://www.preflib.org.","code":""},{"path":"/news/index.html","id":"changes-in-behaviour-0-2-0","dir":"Changelog","previous_headings":"","what":"Changes in behaviour","title":"PlackettLuce 0.2-0","text":"Old behaviour reproducible arguments N number items D maximum order ties. Implement pseudo-data approach - now used default. Improve starting values ability parameters Add Steffensen acceleration iterative scaling algorithm Dropped ref argument PlackettLuce; specified instead calling coef, summary, vcov itempar. qvcalc generic now imported qvcalc","code":"npseudo = 0, steffensen = 0, start = c(rep(1/N, N), rep(0.1, D))"},{"path":"/news/index.html","id":"improvements-0-2-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"PlackettLuce 0.2-0","text":"Refactor code speed model fitting computation fitted values vcov. Implement ranking weights starting values PlackettLuce. Add package tests Add log argument coef worth parameters (probability coming first strict ranking items) can obtained easily.","code":""},{"path":"/news/index.html","id":"plackettluce-01-0","dir":"Changelog","previous_headings":"","what":"PlackettLuce 0.1-0","title":"PlackettLuce 0.1-0","text":"GitHub-release prototype package.","code":""}]
